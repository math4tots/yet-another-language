# AUTOGENERATED yal interface file for gl-matrix version 3.4.1
from 'js/type/float32array' import Float32Array
const __jsLibs = ["gl-matrix.js"]
export interface glMatrix {
  """
  https://glmatrix.net/docs/module-glMatrix.html
  """
  static {
    aliasFor(native "glMatrix.glMatrix")
    function toRadian(a: Number): Number {
      """
      Convert Degree To Radian
      """
      aliasFor(__js_toRadian)
    }
    function equals(a: Number, b: Number): Bool {
      """
      Tests whether or not the arguments have approximately the same value, within an absolute
or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
than or equal to 1.0, and a relative tolerance is used for larger values)
      """
      aliasFor(__js_equals)
    }
  }
  function asFloat32Array(): Float32Array {
    aliasFor(__op_noop__)
  }
}
export interface mat2 {
  """
  https://glmatrix.net/docs/module-mat2.html
  """
  static {
    aliasFor(native "glMatrix.mat2")
    function create(): mat2 {
      """
      Creates a new identity mat2
      """
      aliasFor(__js_create)
    }
    function clone(a: mat2): mat2 {
      """
      Creates a new mat2 initialized with values from an existing matrix
      """
      aliasFor(__js_clone)
    }
    function copy(out: mat2, a: mat2): mat2 {
      """
      Copy the values from one mat2 to another
      """
      aliasFor(__js_copy)
    }
    function identity(out: mat2): mat2 {
      """
      Set a mat2 to the identity matrix
      """
      aliasFor(__js_identity)
    }
    function fromValues(m00: Number, m01: Number, m10: Number, m11: Number): mat2 {
      """
      Create a new mat2 with the given values
      """
      aliasFor(__js_fromValues)
    }
    function set(out: mat2, m00: Number, m01: Number, m10: Number, m11: Number): mat2 {
      """
      Set the components of a mat2 to the given values
      """
      aliasFor(__js_set)
    }
    function transpose(out: mat2, a: mat2): mat2 {
      """
      Transpose the values of a mat2
      """
      aliasFor(__js_transpose)
    }
    function invert(out: mat2, a: mat2): mat2 {
      """
      Inverts a mat2
      """
      aliasFor(__js_invert)
    }
    function adjoint(out: mat2, a: mat2): mat2 {
      """
      Calculates the adjugate of a mat2
      """
      aliasFor(__js_adjoint)
    }
    function determinant(a: mat2): Number {
      """
      Calculates the determinant of a mat2
      """
      aliasFor(__js_determinant)
    }
    function multiply(out: mat2, a: mat2, b: mat2): mat2 {
      """
      Multiplies two mat2's
      """
      aliasFor(__js_multiply)
    }
    function rotate(out: mat2, a: mat2, rad: Number): mat2 {
      """
      Rotates a mat2 by the given angle
      """
      aliasFor(__js_rotate)
    }
    function scale(out: mat2, a: mat2, v: vec2): mat2 {
      """
      Scales the mat2 by the dimensions in the given vec2
      """
      aliasFor(__js_scale)
    }
    function fromRotation(out: mat2, rad: Number): mat2 {
      """
      Creates a matrix from a given angle
This is equivalent to (but much faster than):

    mat2.identity(dest);
    mat2.rotate(dest, dest, rad);
      """
      aliasFor(__js_fromRotation)
    }
    function fromScaling(out: mat2, v: vec2): mat2 {
      """
      Creates a matrix from a vector scaling
This is equivalent to (but much faster than):

    mat2.identity(dest);
    mat2.scale(dest, dest, vec);
      """
      aliasFor(__js_fromScaling)
    }
    function str(a: mat2): String {
      """
      Returns a string representation of a mat2
      """
      aliasFor(__js_str)
    }
    function frob(a: mat2): Number {
      """
      Returns Frobenius norm of a mat2
      """
      aliasFor(__js_frob)
    }
    function add(out: mat2, a: mat2, b: mat2): mat2 {
      """
      Adds two mat2's
      """
      aliasFor(__js_add)
    }
    function subtract(out: mat2, a: mat2, b: mat2): mat2 {
      """
      Subtracts matrix b from matrix a
      """
      aliasFor(__js_subtract)
    }
    function exactEquals(a: mat2, b: mat2): Bool {
      """
      Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
      """
      aliasFor(__js_exactEquals)
    }
    function equals(a: mat2, b: mat2): Bool {
      """
      Returns whether or not the matrices have approximately the same elements in the same position.
      """
      aliasFor(__js_equals)
    }
    function multiplyScalar(out: mat2, a: mat2, b: Number): mat2 {
      """
      Multiply each element of the matrix by a scalar.
      """
      aliasFor(__js_multiplyScalar)
    }
    function multiplyScalarAndAdd(out: mat2, a: mat2, b: mat2, scale: Number): mat2 {
      """
      Adds two mat2's after multiplying each element of the second operand by a scalar value.
      """
      aliasFor(__js_multiplyScalarAndAdd)
    }
    function mul(out: mat2, a: mat2, b: mat2): mat2 {
      """
      Alias for {@link mat2.multiply}
      """
      aliasFor(__js_mul)
    }
    function sub(out: mat2, a: mat2, b: mat2): mat2 {
      """
      Alias for {@link mat2.subtract}
      """
      aliasFor(__js_sub)
    }
  }
  function asFloat32Array(): Float32Array {
    aliasFor(__op_noop__)
  }
}
export interface mat2d {
  """
  https://glmatrix.net/docs/module-mat2d.html
  """
  static {
    aliasFor(native "glMatrix.mat2d")
    function create(): mat2d {
      """
      Creates a new identity mat2d
      """
      aliasFor(__js_create)
    }
    function clone(a: mat2d): mat2d {
      """
      Creates a new mat2d initialized with values from an existing matrix
      """
      aliasFor(__js_clone)
    }
    function copy(out: mat2d, a: mat2d): mat2d {
      """
      Copy the values from one mat2d to another
      """
      aliasFor(__js_copy)
    }
    function identity(out: mat2d): mat2d {
      """
      Set a mat2d to the identity matrix
      """
      aliasFor(__js_identity)
    }
    function fromValues(a: Number, b: Number, c: Number, d: Number, tx: Number, ty: Number): mat2d {
      """
      Create a new mat2d with the given values
      """
      aliasFor(__js_fromValues)
    }
    function set(out: mat2d, a: Number, b: Number, c: Number, d: Number, tx: Number, ty: Number): mat2d {
      """
      Set the components of a mat2d to the given values
      """
      aliasFor(__js_set)
    }
    function invert(out: mat2d, a: mat2d): mat2d {
      """
      Inverts a mat2d
      """
      aliasFor(__js_invert)
    }
    function determinant(a: mat2d): Number {
      """
      Calculates the determinant of a mat2d
      """
      aliasFor(__js_determinant)
    }
    function multiply(out: mat2d, a: mat2d, b: mat2d): mat2d {
      """
      Multiplies two mat2d's
      """
      aliasFor(__js_multiply)
    }
    function rotate(out: mat2d, a: mat2d, rad: Number): mat2d {
      """
      Rotates a mat2d by the given angle
      """
      aliasFor(__js_rotate)
    }
    function scale(out: mat2d, a: mat2d, v: vec2): mat2d {
      """
      Scales the mat2d by the dimensions in the given vec2
      """
      aliasFor(__js_scale)
    }
    function translate(out: mat2d, a: mat2d, v: vec2): mat2d {
      """
      Translates the mat2d by the dimensions in the given vec2
      """
      aliasFor(__js_translate)
    }
    function fromRotation(out: mat2d, rad: Number): mat2d {
      """
      Creates a matrix from a given angle
This is equivalent to (but much faster than):

    mat2d.identity(dest);
    mat2d.rotate(dest, dest, rad);
      """
      aliasFor(__js_fromRotation)
    }
    function fromScaling(out: mat2d, v: vec2): mat2d {
      """
      Creates a matrix from a vector scaling
This is equivalent to (but much faster than):

    mat2d.identity(dest);
    mat2d.scale(dest, dest, vec);
      """
      aliasFor(__js_fromScaling)
    }
    function fromTranslation(out: mat2d, v: vec2): mat2d {
      """
      Creates a matrix from a vector translation
This is equivalent to (but much faster than):

    mat2d.identity(dest);
    mat2d.translate(dest, dest, vec);
      """
      aliasFor(__js_fromTranslation)
    }
    function str(a: mat2d): String {
      """
      Returns a string representation of a mat2d
      """
      aliasFor(__js_str)
    }
    function frob(a: mat2d): Number {
      """
      Returns Frobenius norm of a mat2d
      """
      aliasFor(__js_frob)
    }
    function add(out: mat2d, a: mat2d, b: mat2d): mat2d {
      """
      Adds two mat2d's
      """
      aliasFor(__js_add)
    }
    function subtract(out: mat2d, a: mat2d, b: mat2d): mat2d {
      """
      Subtracts matrix b from matrix a
      """
      aliasFor(__js_subtract)
    }
    function multiplyScalar(out: mat2d, a: mat2d, b: Number): mat2d {
      """
      Multiply each element of the matrix by a scalar.
      """
      aliasFor(__js_multiplyScalar)
    }
    function multiplyScalarAndAdd(out: mat2d, a: mat2d, b: mat2d, scale: Number): mat2d {
      """
      Adds two mat2d's after multiplying each element of the second operand by a scalar value.
      """
      aliasFor(__js_multiplyScalarAndAdd)
    }
    function exactEquals(a: mat2d, b: mat2d): Bool {
      """
      Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
      """
      aliasFor(__js_exactEquals)
    }
    function equals(a: mat2d, b: mat2d): Bool {
      """
      Returns whether or not the matrices have approximately the same elements in the same position.
      """
      aliasFor(__js_equals)
    }
    function mul(out: mat2d, a: mat2d, b: mat2d): mat2d {
      """
      Alias for {@link mat2d.multiply}
      """
      aliasFor(__js_mul)
    }
    function sub(out: mat2d, a: mat2d, b: mat2d): mat2d {
      """
      Alias for {@link mat2d.subtract}
      """
      aliasFor(__js_sub)
    }
  }
  function asFloat32Array(): Float32Array {
    aliasFor(__op_noop__)
  }
}
export interface mat3 {
  """
  https://glmatrix.net/docs/module-mat3.html
  """
  static {
    aliasFor(native "glMatrix.mat3")
    function create(): mat3 {
      """
      Creates a new identity mat3
      """
      aliasFor(__js_create)
    }
    function fromMat4(out: mat3, a: mat4): mat3 {
      """
      Copies the upper-left 3x3 values into the given mat3.
      """
      aliasFor(__js_fromMat4)
    }
    function clone(a: mat3): mat3 {
      """
      Creates a new mat3 initialized with values from an existing matrix
      """
      aliasFor(__js_clone)
    }
    function copy(out: mat3, a: mat3): mat3 {
      """
      Copy the values from one mat3 to another
      """
      aliasFor(__js_copy)
    }
    function fromValues(m00: Number, m01: Number, m02: Number, m10: Number, m11: Number, m12: Number, m20: Number, m21: Number, m22: Number): mat3 {
      """
      Create a new mat3 with the given values
      """
      aliasFor(__js_fromValues)
    }
    function set(out: mat3, m00: Number, m01: Number, m02: Number, m10: Number, m11: Number, m12: Number, m20: Number, m21: Number, m22: Number): mat3 {
      """
      Set the components of a mat3 to the given values
      """
      aliasFor(__js_set)
    }
    function identity(out: mat3): mat3 {
      """
      Set a mat3 to the identity matrix
      """
      aliasFor(__js_identity)
    }
    function transpose(out: mat3, a: mat3): mat3 {
      """
      Transpose the values of a mat3
      """
      aliasFor(__js_transpose)
    }
    function invert(out: mat3, a: mat3): mat3 {
      """
      Inverts a mat3
      """
      aliasFor(__js_invert)
    }
    function adjoint(out: mat3, a: mat3): mat3 {
      """
      Calculates the adjugate of a mat3
      """
      aliasFor(__js_adjoint)
    }
    function determinant(a: mat3): Number {
      """
      Calculates the determinant of a mat3
      """
      aliasFor(__js_determinant)
    }
    function multiply(out: mat3, a: mat3, b: mat3): mat3 {
      """
      Multiplies two mat3's
      """
      aliasFor(__js_multiply)
    }
    function translate(out: mat3, a: mat3, v: vec2): mat3 {
      """
      Translate a mat3 by the given vector
      """
      aliasFor(__js_translate)
    }
    function rotate(out: mat3, a: mat3, rad: Number): mat3 {
      """
      Rotates a mat3 by the given angle
      """
      aliasFor(__js_rotate)
    }
    function scale(out: mat3, a: mat3, v: vec2): mat3 {
      """
      Scales the mat3 by the dimensions in the given vec2
      """
      aliasFor(__js_scale)
    }
    function fromTranslation(out: mat3, v: vec2): mat3 {
      """
      Creates a matrix from a vector translation
This is equivalent to (but much faster than):

    mat3.identity(dest);
    mat3.translate(dest, dest, vec);
      """
      aliasFor(__js_fromTranslation)
    }
    function fromRotation(out: mat3, rad: Number): mat3 {
      """
      Creates a matrix from a given angle
This is equivalent to (but much faster than):

    mat3.identity(dest);
    mat3.rotate(dest, dest, rad);
      """
      aliasFor(__js_fromRotation)
    }
    function fromScaling(out: mat3, v: vec2): mat3 {
      """
      Creates a matrix from a vector scaling
This is equivalent to (but much faster than):

    mat3.identity(dest);
    mat3.scale(dest, dest, vec);
      """
      aliasFor(__js_fromScaling)
    }
    function fromMat2d(out: mat3, a: mat2d): mat3 {
      """
      Copies the values from a mat2d into a mat3
      """
      aliasFor(__js_fromMat2d)
    }
    function fromQuat(out: mat3, q: quat): mat3 {
      """
      Calculates a 3x3 matrix from the given quaternion
      """
      aliasFor(__js_fromQuat)
    }
    function normalFromMat4(out: mat3, a: mat4): mat3 {
      """
      Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
      """
      aliasFor(__js_normalFromMat4)
    }
    function projection(out: mat3, width: Number, height: Number): mat3 {
      """
      Generates a 2D projection matrix with the given bounds
      """
      aliasFor(__js_projection)
    }
    function str(a: mat3): String {
      """
      Returns a string representation of a mat3
      """
      aliasFor(__js_str)
    }
    function frob(a: mat3): Number {
      """
      Returns Frobenius norm of a mat3
      """
      aliasFor(__js_frob)
    }
    function add(out: mat3, a: mat3, b: mat3): mat3 {
      """
      Adds two mat3's
      """
      aliasFor(__js_add)
    }
    function subtract(out: mat3, a: mat3, b: mat3): mat3 {
      """
      Subtracts matrix b from matrix a
      """
      aliasFor(__js_subtract)
    }
    function multiplyScalar(out: mat3, a: mat3, b: Number): mat3 {
      """
      Multiply each element of the matrix by a scalar.
      """
      aliasFor(__js_multiplyScalar)
    }
    function multiplyScalarAndAdd(out: mat3, a: mat3, b: mat3, scale: Number): mat3 {
      """
      Adds two mat3's after multiplying each element of the second operand by a scalar value.
      """
      aliasFor(__js_multiplyScalarAndAdd)
    }
    function exactEquals(a: mat3, b: mat3): Bool {
      """
      Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
      """
      aliasFor(__js_exactEquals)
    }
    function equals(a: mat3, b: mat3): Bool {
      """
      Returns whether or not the matrices have approximately the same elements in the same position.
      """
      aliasFor(__js_equals)
    }
    function mul(out: mat3, a: mat3, b: mat3): mat3 {
      """
      Alias for {@link mat3.multiply}
      """
      aliasFor(__js_mul)
    }
    function sub(out: mat3, a: mat3, b: mat3): mat3 {
      """
      Alias for {@link mat3.subtract}
      """
      aliasFor(__js_sub)
    }
  }
  function asFloat32Array(): Float32Array {
    aliasFor(__op_noop__)
  }
}
export interface mat4 {
  """
  https://glmatrix.net/docs/module-mat4.html
  """
  static {
    aliasFor(native "glMatrix.mat4")
    function create(): mat4 {
      """
      Creates a new identity mat4
      """
      aliasFor(__js_create)
    }
    function clone(a: mat4): mat4 {
      """
      Creates a new mat4 initialized with values from an existing matrix
      """
      aliasFor(__js_clone)
    }
    function copy(out: mat4, a: mat4): mat4 {
      """
      Copy the values from one mat4 to another
      """
      aliasFor(__js_copy)
    }
    function fromValues(m00: Number, m01: Number, m02: Number, m03: Number, m10: Number, m11: Number, m12: Number, m13: Number, m20: Number, m21: Number, m22: Number, m23: Number, m30: Number, m31: Number, m32: Number, m33: Number): mat4 {
      """
      Create a new mat4 with the given values
      """
      aliasFor(__js_fromValues)
    }
    function set(out: mat4, m00: Number, m01: Number, m02: Number, m03: Number, m10: Number, m11: Number, m12: Number, m13: Number, m20: Number, m21: Number, m22: Number, m23: Number, m30: Number, m31: Number, m32: Number, m33: Number): mat4 {
      """
      Set the components of a mat4 to the given values
      """
      aliasFor(__js_set)
    }
    function identity(out: mat4): mat4 {
      """
      Set a mat4 to the identity matrix
      """
      aliasFor(__js_identity)
    }
    function transpose(out: mat4, a: mat4): mat4 {
      """
      Transpose the values of a mat4
      """
      aliasFor(__js_transpose)
    }
    function invert(out: mat4, a: mat4): mat4 {
      """
      Inverts a mat4
      """
      aliasFor(__js_invert)
    }
    function adjoint(out: mat4, a: mat4): mat4 {
      """
      Calculates the adjugate of a mat4
      """
      aliasFor(__js_adjoint)
    }
    function determinant(a: mat4): Number {
      """
      Calculates the determinant of a mat4
      """
      aliasFor(__js_determinant)
    }
    function multiply(out: mat4, a: mat4, b: mat4): mat4 {
      """
      Multiplies two mat4s
      """
      aliasFor(__js_multiply)
    }
    function translate(out: mat4, a: mat4, v: vec3): mat4 {
      """
      Translate a mat4 by the given vector
      """
      aliasFor(__js_translate)
    }
    function scale(out: mat4, a: mat4, v: vec3): mat4 {
      """
      Scales the mat4 by the dimensions in the given vec3 not using vectorization
      """
      aliasFor(__js_scale)
    }
    function rotate(out: mat4, a: mat4, rad: Number, axis: vec3): mat4 {
      """
      Rotates a mat4 by the given angle around the given axis
      """
      aliasFor(__js_rotate)
    }
    function rotateX(out: mat4, a: mat4, rad: Number): mat4 {
      """
      Rotates a matrix by the given angle around the X axis
      """
      aliasFor(__js_rotateX)
    }
    function rotateY(out: mat4, a: mat4, rad: Number): mat4 {
      """
      Rotates a matrix by the given angle around the Y axis
      """
      aliasFor(__js_rotateY)
    }
    function rotateZ(out: mat4, a: mat4, rad: Number): mat4 {
      """
      Rotates a matrix by the given angle around the Z axis
      """
      aliasFor(__js_rotateZ)
    }
    function fromTranslation(out: mat4, v: vec3): mat4 {
      """
      Creates a matrix from a vector translation
This is equivalent to (but much faster than):

    mat4.identity(dest);
    mat4.translate(dest, dest, vec);
      """
      aliasFor(__js_fromTranslation)
    }
    function fromScaling(out: mat4, v: vec3): mat4 {
      """
      Creates a matrix from a vector scaling
This is equivalent to (but much faster than):

    mat4.identity(dest);
    mat4.scale(dest, dest, vec);
      """
      aliasFor(__js_fromScaling)
    }
    function fromRotation(out: mat4, rad: Number, axis: vec3): mat4 {
      """
      Creates a matrix from a given angle around a given axis
This is equivalent to (but much faster than):

    mat4.identity(dest);
    mat4.rotate(dest, dest, rad, axis);
      """
      aliasFor(__js_fromRotation)
    }
    function fromXRotation(out: mat4, rad: Number): mat4 {
      """
      Creates a matrix from the given angle around the X axis
This is equivalent to (but much faster than):

    mat4.identity(dest);
    mat4.rotateX(dest, dest, rad);
      """
      aliasFor(__js_fromXRotation)
    }
    function fromYRotation(out: mat4, rad: Number): mat4 {
      """
      Creates a matrix from the given angle around the Y axis
This is equivalent to (but much faster than):

    mat4.identity(dest);
    mat4.rotateY(dest, dest, rad);
      """
      aliasFor(__js_fromYRotation)
    }
    function fromZRotation(out: mat4, rad: Number): mat4 {
      """
      Creates a matrix from the given angle around the Z axis
This is equivalent to (but much faster than):

    mat4.identity(dest);
    mat4.rotateZ(dest, dest, rad);
      """
      aliasFor(__js_fromZRotation)
    }
    function fromQuat2(out: mat4, a: quat2): mat4 {
      """
      Creates a new mat4 from a dual quat.
      """
      aliasFor(__js_fromQuat2)
    }
    function getTranslation(out: vec3, mat: mat4): vec3 {
      """
      Returns the translation vector component of a transformation
 matrix. If a matrix is built with fromRotationTranslation,
 the returned vector will be the same as the translation vector
 originally supplied.
      """
      aliasFor(__js_getTranslation)
    }
    function getScaling(out: vec3, mat: mat4): vec3 {
      """
      Returns the scaling factor component of a transformation
 matrix. If a matrix is built with fromRotationTranslationScale
 with a normalized Quaternion paramter, the returned vector will be
 the same as the scaling vector
 originally supplied.
      """
      aliasFor(__js_getScaling)
    }
    function getRotation(out: quat, mat: mat4): quat {
      """
      Returns a quaternion representing the rotational component
 of a transformation matrix. If a matrix is built with
 fromRotationTranslation, the returned quaternion will be the
 same as the quaternion originally supplied.
      """
      aliasFor(__js_getRotation)
    }
    function decompose(out_r: quat, out_t: vec3, out_s: vec3, mat: mat4): quat {
      """
      Decomposes a transformation matrix into its rotation, translation
and scale components. Returns only the rotation component
      """
      aliasFor(__js_decompose)
    }
    function fromQuat(out: mat4, q: quat): mat4 {
      """
      Calculates a 4x4 matrix from the given quaternion
      """
      aliasFor(__js_fromQuat)
    }
    function frustum(out: mat4, left: Number, right: Number, bottom: Number, top: Number, near: Number, far: Number): mat4 {
      """
      Generates a frustum matrix with the given bounds
      """
      aliasFor(__js_frustum)
    }
    function perspectiveNO(out: mat4, fovy: Number, aspect: Number, near: Number, far: Number): mat4 {
      """
      Generates a perspective projection matrix with the given bounds.
The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
which matches WebGL/OpenGL's clip volume.
Passing null/undefined/no value for far will generate infinite projection matrix.
      """
      aliasFor(__js_perspectiveNO)
    }
    function perspective(out: mat4, fovy: Number, aspect: Number, near: Number, far: Number): mat4 {
      """
      Alias for {@link mat4.perspectiveNO}
      """
      aliasFor(__js_perspective)
    }
    function perspectiveZO(out: mat4, fovy: Number, aspect: Number, near: Number, far: Number): mat4 {
      """
      Generates a perspective projection matrix suitable for WebGPU with the given bounds.
The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],
which matches WebGPU/Vulkan/DirectX/Metal's clip volume.
Passing null/undefined/no value for far will generate infinite projection matrix.
      """
      aliasFor(__js_perspectiveZO)
    }
    function perspectiveFromFieldOfView(out: mat4, fov: Any, near: Number, far: Number): mat4 {
      """
      Generates a perspective projection matrix with the given field of view.
This is primarily useful for generating projection matrices to be used
with the still experiemental WebVR API.
      """
      aliasFor(__js_perspectiveFromFieldOfView)
    }
    function orthoNO(out: mat4, left: Number, right: Number, bottom: Number, top: Number, near: Number, far: Number): mat4 {
      """
      Generates a orthogonal projection matrix with the given bounds.
The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
which matches WebGL/OpenGL's clip volume.
      """
      aliasFor(__js_orthoNO)
    }
    function ortho(out: mat4, left: Number, right: Number, bottom: Number, top: Number, near: Number, far: Number): mat4 {
      """
      Alias for {@link mat4.orthoNO}
      """
      aliasFor(__js_ortho)
    }
    function orthoZO(out: mat4, left: Number, right: Number, bottom: Number, top: Number, near: Number, far: Number): mat4 {
      """
      Generates a orthogonal projection matrix with the given bounds.
The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],
which matches WebGPU/Vulkan/DirectX/Metal's clip volume.
      """
      aliasFor(__js_orthoZO)
    }
    function lookAt(out: mat4, eye: vec3, center: vec3, up: vec3): mat4 {
      """
      Generates a look-at matrix with the given eye position, focal point, and up axis.
If you want a matrix that actually makes an object look at another object, you should use targetTo instead.
      """
      aliasFor(__js_lookAt)
    }
    function targetTo(out: mat4, eye: vec3, center: vec3, up: vec3): mat4 {
      """
      Generates a matrix that makes something look at something else.
      """
      aliasFor(__js_targetTo)
    }
    function str(a: mat4): String {
      """
      Returns a string representation of a mat4
      """
      aliasFor(__js_str)
    }
    function frob(a: mat4): Number {
      """
      Returns Frobenius norm of a mat4
      """
      aliasFor(__js_frob)
    }
    function add(out: mat4, a: mat4, b: mat4): mat4 {
      """
      Adds two mat4's
      """
      aliasFor(__js_add)
    }
    function subtract(out: mat4, a: mat4, b: mat4): mat4 {
      """
      Subtracts matrix b from matrix a
      """
      aliasFor(__js_subtract)
    }
    function multiplyScalar(out: mat4, a: mat4, b: Number): mat4 {
      """
      Multiply each element of the matrix by a scalar.
      """
      aliasFor(__js_multiplyScalar)
    }
    function multiplyScalarAndAdd(out: mat4, a: mat4, b: mat4, scale: Number): mat4 {
      """
      Adds two mat4's after multiplying each element of the second operand by a scalar value.
      """
      aliasFor(__js_multiplyScalarAndAdd)
    }
    function exactEquals(a: mat4, b: mat4): Bool {
      """
      Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
      """
      aliasFor(__js_exactEquals)
    }
    function equals(a: mat4, b: mat4): Bool {
      """
      Returns whether or not the matrices have approximately the same elements in the same position.
      """
      aliasFor(__js_equals)
    }
    function mul(out: mat4, a: mat4, b: mat4): mat4 {
      """
      Alias for {@link mat4.multiply}
      """
      aliasFor(__js_mul)
    }
    function sub(out: mat4, a: mat4, b: mat4): mat4 {
      """
      Alias for {@link mat4.subtract}
      """
      aliasFor(__js_sub)
    }
  }
  function asFloat32Array(): Float32Array {
    aliasFor(__op_noop__)
  }
}
export interface quat {
  """
  https://glmatrix.net/docs/module-quat.html
  """
  static {
    aliasFor(native "glMatrix.quat")
    function create(): quat {
      """
      Creates a new identity quat
      """
      aliasFor(__js_create)
    }
    function identity(out: quat): quat {
      """
      Set a quat to the identity quaternion
      """
      aliasFor(__js_identity)
    }
    function setAxisAngle(out: quat, axis: vec3, rad: Number): quat {
      """
      Sets a quat from the given angle and rotation axis,
then returns it.
      """
      aliasFor(__js_setAxisAngle)
    }
    function getAxisAngle(out_axis: vec3, q: quat): Number {
      """
      Gets the rotation axis and angle for a given
 quaternion. If a quaternion is created with
 setAxisAngle, this method will return the same
 values as providied in the original parameter list
 OR functionally equivalent values.
Example: The quaternion formed by axis [0, 0, 1] and
 angle -90 is the same as the quaternion formed by
 [0, 0, 1] and 270. This method favors the latter.
      """
      aliasFor(__js_getAxisAngle)
    }
    function getAngle(a: quat, b: quat): Number {
      """
      Gets the angular distance between two unit quaternions
      """
      aliasFor(__js_getAngle)
    }
    function multiply(out: quat, a: quat, b: quat): quat {
      """
      Multiplies two quat's
      """
      aliasFor(__js_multiply)
    }
    function rotateX(out: quat, a: quat, rad: Number): quat {
      """
      Rotates a quaternion by the given angle about the X axis
      """
      aliasFor(__js_rotateX)
    }
    function rotateY(out: quat, a: quat, rad: Number): quat {
      """
      Rotates a quaternion by the given angle about the Y axis
      """
      aliasFor(__js_rotateY)
    }
    function rotateZ(out: quat, a: quat, rad: Number): quat {
      """
      Rotates a quaternion by the given angle about the Z axis
      """
      aliasFor(__js_rotateZ)
    }
    function calculateW(out: quat, a: quat): quat {
      """
      Calculates the W component of a quat from the X, Y, and Z components.
Assumes that quaternion is 1 unit in length.
Any existing W component will be ignored.
      """
      aliasFor(__js_calculateW)
    }
    function exp(out: quat, a: quat): quat {
      """
      Calculate the exponential of a unit quaternion.
      """
      aliasFor(__js_exp)
    }
    function ln(out: quat, a: quat): quat {
      """
      Calculate the natural logarithm of a unit quaternion.
      """
      aliasFor(__js_ln)
    }
    function pow(out: quat, a: quat, b: Number): quat {
      """
      Calculate the scalar power of a unit quaternion.
      """
      aliasFor(__js_pow)
    }
    function slerp(out: quat, a: quat, b: quat, t: Number): quat {
      """
      Performs a spherical linear interpolation between two quat
      """
      aliasFor(__js_slerp)
    }
    function random(out: quat): quat {
      """
      Generates a random unit quaternion
      """
      aliasFor(__js_random)
    }
    function invert(out: quat, a: quat): quat {
      """
      Calculates the inverse of a quat
      """
      aliasFor(__js_invert)
    }
    function conjugate(out: quat, a: quat): quat {
      """
      Calculates the conjugate of a quat
If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
      """
      aliasFor(__js_conjugate)
    }
    function fromMat3(out: quat, m: mat3): quat {
      """
      Creates a quaternion from the given 3x3 rotation matrix.

NOTE: The resultant quaternion is not normalized, so you should be sure
to renormalize the quaternion yourself where necessary.
      """
      aliasFor(__js_fromMat3)
    }
    function fromEuler(out: quat, x: Number, y: Number, z: Number, order: String): quat {
      """
      Creates a quaternion from the given euler angle x, y, z using the provided intrinsic order for the conversion.
      """
      aliasFor(__js_fromEuler)
    }
    function str(a: quat): String {
      """
      Returns a string representation of a quaternion
      """
      aliasFor(__js_str)
    }
    function clone(a: quat): quat {
      """
      Creates a new quat initialized with values from an existing quaternion
      """
      aliasFor(__js_clone)
    }
    function fromValues(x: Number, y: Number, z: Number, w: Number): quat {
      """
      Creates a new quat initialized with the given values
      """
      aliasFor(__js_fromValues)
    }
    function copy(out: quat, a: quat): quat {
      """
      Copy the values from one quat to another
      """
      aliasFor(__js_copy)
    }
    function set(out: quat, x: Number, y: Number, z: Number, w: Number): quat {
      """
      Set the components of a quat to the given values
      """
      aliasFor(__js_set)
    }
    function add(out: quat, a: quat, b: quat): quat {
      """
      Adds two quat's
      """
      aliasFor(__js_add)
    }
    function mul(out: quat, a: quat, b: quat): quat {
      """
      Alias for {@link quat.multiply}
      """
      aliasFor(__js_mul)
    }
    function scale(out: quat, a: quat, b: Number): quat {
      """
      Scales a quat by a scalar number
      """
      aliasFor(__js_scale)
    }
    function dot(a: quat, b: quat): Number {
      """
      Calculates the dot product of two quat's
      """
      aliasFor(__js_dot)
    }
    function lerp(out: quat, a: quat, b: quat, t: Number): quat {
      """
      Performs a linear interpolation between two quat's
      """
      aliasFor(__js_lerp)
    }
    function len(a: quat): Number {
      """
      Alias for {@link quat.length}
      """
      aliasFor(__js_len)
    }
    function squaredLength(a: quat): Number {
      """
      Calculates the squared length of a quat
      """
      aliasFor(__js_squaredLength)
    }
    function sqrLen(a: quat): Number {
      """
      Alias for {@link quat.squaredLength}
      """
      aliasFor(__js_sqrLen)
    }
    function normalize(out: quat, a: quat): quat {
      """
      Normalize a quat
      """
      aliasFor(__js_normalize)
    }
    function equals(a: quat, b: quat): Bool {
      """
      Returns whether or not the quaternions point approximately to the same direction.

Both quaternions are assumed to be unit length.
      """
      aliasFor(__js_equals)
    }
  }
  function asFloat32Array(): Float32Array {
    aliasFor(__op_noop__)
  }
}
export interface quat2 {
  """
  https://glmatrix.net/docs/module-quat2.html
  """
  static {
    aliasFor(native "glMatrix.quat2")
    function create(): quat2 {
      """
      Creates a new identity dual quat
      """
      aliasFor(__js_create)
    }
    function clone(a: quat2): quat2 {
      """
      Creates a new quat initialized with values from an existing quaternion
      """
      aliasFor(__js_clone)
    }
    function fromValues(x1: Number, y1: Number, z1: Number, w1: Number, x2: Number, y2: Number, z2: Number, w2: Number): quat2 {
      """
      Creates a new dual quat initialized with the given values
      """
      aliasFor(__js_fromValues)
    }
    function fromRotationTranslationValues(x1: Number, y1: Number, z1: Number, w1: Number, x2: Number, y2: Number, z2: Number): quat2 {
      """
      Creates a new dual quat from the given values (quat and translation)
      """
      aliasFor(__js_fromRotationTranslationValues)
    }
    function fromRotationTranslation(dual: quat2, q: quat, t: vec3): quat2 {
      """
      Creates a dual quat from a quaternion and a translation
      """
      aliasFor(__js_fromRotationTranslation)
    }
    function fromTranslation(dual: quat2, t: vec3): quat2 {
      """
      Creates a dual quat from a translation
      """
      aliasFor(__js_fromTranslation)
    }
    function fromRotation(dual: quat2, q: quat): quat2 {
      """
      Creates a dual quat from a quaternion
      """
      aliasFor(__js_fromRotation)
    }
    function fromMat4(out: quat2, a: mat4): quat2 {
      """
      Creates a new dual quat from a matrix (4x4)
      """
      aliasFor(__js_fromMat4)
    }
    function copy(out: quat2, a: quat2): quat2 {
      """
      Copy the values from one dual quat to another
      """
      aliasFor(__js_copy)
    }
    function identity(out: quat2): quat2 {
      """
      Set a dual quat to the identity dual quaternion
      """
      aliasFor(__js_identity)
    }
    function set(out: quat2, x1: Number, y1: Number, z1: Number, w1: Number, x2: Number, y2: Number, z2: Number, w2: Number): quat2 {
      """
      Set the components of a dual quat to the given values
      """
      aliasFor(__js_set)
    }
    function getDual(out: quat, a: quat2): quat {
      """
      Gets the dual part of a dual quat
      """
      aliasFor(__js_getDual)
    }
    function setReal(out: quat2, q: quat): quat2 {
      """
      Set the real component of a dual quat to the given quaternion
      """
      aliasFor(__js_setReal)
    }
    function setDual(out: quat2, q: quat): quat2 {
      """
      Set the dual component of a dual quat to the given quaternion
      """
      aliasFor(__js_setDual)
    }
    function getTranslation(out: vec3, a: quat2): vec3 {
      """
      Gets the translation of a normalized dual quat
      """
      aliasFor(__js_getTranslation)
    }
    function translate(out: quat2, a: quat2, v: vec3): quat2 {
      """
      Translates a dual quat by the given vector
      """
      aliasFor(__js_translate)
    }
    function rotateX(out: quat2, a: quat2, rad: Number): quat2 {
      """
      Rotates a dual quat around the X axis
      """
      aliasFor(__js_rotateX)
    }
    function rotateY(out: quat2, a: quat2, rad: Number): quat2 {
      """
      Rotates a dual quat around the Y axis
      """
      aliasFor(__js_rotateY)
    }
    function rotateZ(out: quat2, a: quat2, rad: Number): quat2 {
      """
      Rotates a dual quat around the Z axis
      """
      aliasFor(__js_rotateZ)
    }
    function rotateByQuatAppend(out: quat2, a: quat2, q: quat): quat2 {
      """
      Rotates a dual quat by a given quaternion (a * q)
      """
      aliasFor(__js_rotateByQuatAppend)
    }
    function rotateByQuatPrepend(out: quat2, q: quat, a: quat2): quat2 {
      """
      Rotates a dual quat by a given quaternion (q * a)
      """
      aliasFor(__js_rotateByQuatPrepend)
    }
    function rotateAroundAxis(out: quat2, a: quat2, axis: vec3, rad: Number): quat2 {
      """
      Rotates a dual quat around a given axis. Does the normalisation automatically
      """
      aliasFor(__js_rotateAroundAxis)
    }
    function add(out: quat2, a: quat2, b: quat2): quat2 {
      """
      Adds two dual quat's
      """
      aliasFor(__js_add)
    }
    function multiply(out: quat2, a: quat2, b: quat2): quat2 {
      """
      Multiplies two dual quat's
      """
      aliasFor(__js_multiply)
    }
    function mul(out: quat2, a: quat2, b: quat2): quat2 {
      """
      Alias for {@link quat2.multiply}
      """
      aliasFor(__js_mul)
    }
    function scale(out: quat2, a: quat2, b: Number): quat2 {
      """
      Scales a dual quat by a scalar number
      """
      aliasFor(__js_scale)
    }
    function dot(a: quat2, b: quat2): Number {
      """
      Calculates the dot product of two dual quat's (The dot product of the real parts)
      """
      aliasFor(__js_dot)
    }
    function lerp(out: quat2, a: quat2, b: quat2, t: Number): quat2 {
      """
      Performs a linear interpolation between two dual quats's
NOTE: The resulting dual quaternions won't always be normalized (The error is most noticeable when t = 0.5)
      """
      aliasFor(__js_lerp)
    }
    function invert(out: quat2, a: quat2): quat2 {
      """
      Calculates the inverse of a dual quat. If they are normalized, conjugate is cheaper
      """
      aliasFor(__js_invert)
    }
    function conjugate(out: quat2, a: quat2): quat2 {
      """
      Calculates the conjugate of a dual quat
If the dual quaternion is normalized, this function is faster than quat2.inverse and produces the same result.
      """
      aliasFor(__js_conjugate)
    }
    function length(a: quat2): Number {
      """
      Calculates the length of a dual quat
      """
      aliasFor(__js_length)
    }
    function len(a: quat2): Number {
      """
      Alias for {@link quat2.length}
      """
      aliasFor(__js_len)
    }
    function squaredLength(a: quat2): Number {
      """
      Calculates the squared length of a dual quat
      """
      aliasFor(__js_squaredLength)
    }
    function sqrLen(a: quat2): Number {
      """
      Alias for {@link quat2.squaredLength}
      """
      aliasFor(__js_sqrLen)
    }
    function normalize(out: quat2, a: quat2): quat2 {
      """
      Normalize a dual quat
      """
      aliasFor(__js_normalize)
    }
    function str(a: quat2): String {
      """
      Returns a string representation of a dual quaternion
      """
      aliasFor(__js_str)
    }
    function exactEquals(a: quat2, b: quat2): Bool {
      """
      Returns whether or not the dual quaternions have exactly the same elements in the same position (when compared with ===)
      """
      aliasFor(__js_exactEquals)
    }
    function equals(a: quat2, b: quat2): Bool {
      """
      Returns whether or not the dual quaternions have approximately the same elements in the same position.
      """
      aliasFor(__js_equals)
    }
  }
  function asFloat32Array(): Float32Array {
    aliasFor(__op_noop__)
  }
}
export interface vec2 {
  """
  https://glmatrix.net/docs/module-vec2.html
  """
  static {
    aliasFor(native "glMatrix.vec2")
    function create(): vec2 {
      """
      Creates a new, empty vec2
      """
      aliasFor(__js_create)
    }
    function clone(a: vec2): vec2 {
      """
      Creates a new vec2 initialized with values from an existing vector
      """
      aliasFor(__js_clone)
    }
    function fromValues(x: Number, y: Number): vec2 {
      """
      Creates a new vec2 initialized with the given values
      """
      aliasFor(__js_fromValues)
    }
    function copy(out: vec2, a: vec2): vec2 {
      """
      Copy the values from one vec2 to another
      """
      aliasFor(__js_copy)
    }
    function set(out: vec2, x: Number, y: Number): vec2 {
      """
      Set the components of a vec2 to the given values
      """
      aliasFor(__js_set)
    }
    function add(out: vec2, a: vec2, b: vec2): vec2 {
      """
      Adds two vec2's
      """
      aliasFor(__js_add)
    }
    function subtract(out: vec2, a: vec2, b: vec2): vec2 {
      """
      Subtracts vector b from vector a
      """
      aliasFor(__js_subtract)
    }
    function multiply(out: vec2, a: vec2, b: vec2): vec2 {
      """
      Multiplies two vec2's
      """
      aliasFor(__js_multiply)
    }
    function divide(out: vec2, a: vec2, b: vec2): vec2 {
      """
      Divides two vec2's
      """
      aliasFor(__js_divide)
    }
    function ceil(out: vec2, a: vec2): vec2 {
      """
      Math.ceil the components of a vec2
      """
      aliasFor(__js_ceil)
    }
    function floor(out: vec2, a: vec2): vec2 {
      """
      Math.floor the components of a vec2
      """
      aliasFor(__js_floor)
    }
    function min(out: vec2, a: vec2, b: vec2): vec2 {
      """
      Returns the minimum of two vec2's
      """
      aliasFor(__js_min)
    }
    function max(out: vec2, a: vec2, b: vec2): vec2 {
      """
      Returns the maximum of two vec2's
      """
      aliasFor(__js_max)
    }
    function round(out: vec2, a: vec2): vec2 {
      """
      Math.round the components of a vec2
      """
      aliasFor(__js_round)
    }
    function scale(out: vec2, a: vec2, b: Number): vec2 {
      """
      Scales a vec2 by a scalar number
      """
      aliasFor(__js_scale)
    }
    function scaleAndAdd(out: vec2, a: vec2, b: vec2, scale: Number): vec2 {
      """
      Adds two vec2's after scaling the second operand by a scalar value
      """
      aliasFor(__js_scaleAndAdd)
    }
    function distance(a: vec2, b: vec2): Number {
      """
      Calculates the euclidian distance between two vec2's
      """
      aliasFor(__js_distance)
    }
    function squaredDistance(a: vec2, b: vec2): Number {
      """
      Calculates the squared euclidian distance between two vec2's
      """
      aliasFor(__js_squaredDistance)
    }
    function length(a: vec2): Number {
      """
      Calculates the length of a vec2
      """
      aliasFor(__js_length)
    }
    function squaredLength(a: vec2): Number {
      """
      Calculates the squared length of a vec2
      """
      aliasFor(__js_squaredLength)
    }
    function negate(out: vec2, a: vec2): vec2 {
      """
      Negates the components of a vec2
      """
      aliasFor(__js_negate)
    }
    function inverse(out: vec2, a: vec2): vec2 {
      """
      Returns the inverse of the components of a vec2
      """
      aliasFor(__js_inverse)
    }
    function normalize(out: vec2, a: vec2): vec2 {
      """
      Normalize a vec2
      """
      aliasFor(__js_normalize)
    }
    function dot(a: vec2, b: vec2): Number {
      """
      Calculates the dot product of two vec2's
      """
      aliasFor(__js_dot)
    }
    function cross(out: vec3, a: vec2, b: vec2): vec3 {
      """
      Computes the cross product of two vec2's
Note that the cross product must by definition produce a 3D vector
      """
      aliasFor(__js_cross)
    }
    function lerp(out: vec2, a: vec2, b: vec2, t: Number): vec2 {
      """
      Performs a linear interpolation between two vec2's
      """
      aliasFor(__js_lerp)
    }
    function random(out: vec2, scale: Number): vec2 {
      """
      Generates a random vector with the given scale
      """
      aliasFor(__js_random)
    }
    function transformMat2(out: vec2, a: vec2, m: mat2): vec2 {
      """
      Transforms the vec2 with a mat2
      """
      aliasFor(__js_transformMat2)
    }
    function transformMat2d(out: vec2, a: vec2, m: mat2d): vec2 {
      """
      Transforms the vec2 with a mat2d
      """
      aliasFor(__js_transformMat2d)
    }
    function transformMat3(out: vec2, a: vec2, m: mat3): vec2 {
      """
      Transforms the vec2 with a mat3
3rd vector component is implicitly '1'
      """
      aliasFor(__js_transformMat3)
    }
    function transformMat4(out: vec2, a: vec2, m: mat4): vec2 {
      """
      Transforms the vec2 with a mat4
3rd vector component is implicitly '0'
4th vector component is implicitly '1'
      """
      aliasFor(__js_transformMat4)
    }
    function rotate(out: vec2, a: vec2, b: vec2, rad: Number): vec2 {
      """
      Rotate a 2D vector
      """
      aliasFor(__js_rotate)
    }
    function angle(a: vec2, b: vec2): Number {
      """
      Get the angle between two 2D vectors
      """
      aliasFor(__js_angle)
    }
    function zero(out: vec2): vec2 {
      """
      Set the components of a vec2 to zero
      """
      aliasFor(__js_zero)
    }
    function str(a: vec2): String {
      """
      Returns a string representation of a vector
      """
      aliasFor(__js_str)
    }
    function exactEquals(a: vec2, b: vec2): Bool {
      """
      Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
      """
      aliasFor(__js_exactEquals)
    }
    function equals(a: vec2, b: vec2): Bool {
      """
      Returns whether or not the vectors have approximately the same elements in the same position.
      """
      aliasFor(__js_equals)
    }
    function len(a: vec2): Number {
      """
      Alias for {@link vec2.length}
      """
      aliasFor(__js_len)
    }
    function sub(out: vec2, a: vec2, b: vec2): vec2 {
      """
      Alias for {@link vec2.subtract}
      """
      aliasFor(__js_sub)
    }
    function mul(out: vec2, a: vec2, b: vec2): vec2 {
      """
      Alias for {@link vec2.multiply}
      """
      aliasFor(__js_mul)
    }
    function div(out: vec2, a: vec2, b: vec2): vec2 {
      """
      Alias for {@link vec2.divide}
      """
      aliasFor(__js_div)
    }
    function dist(a: vec2, b: vec2): Number {
      """
      Alias for {@link vec2.distance}
      """
      aliasFor(__js_dist)
    }
    function sqrDist(a: vec2, b: vec2): Number {
      """
      Alias for {@link vec2.squaredDistance}
      """
      aliasFor(__js_sqrDist)
    }
    function sqrLen(a: vec2): Number {
      """
      Alias for {@link vec2.squaredLength}
      """
      aliasFor(__js_sqrLen)
    }
  }
  function asFloat32Array(): Float32Array {
    aliasFor(__op_noop__)
  }
}
export interface vec3 {
  """
  https://glmatrix.net/docs/module-vec3.html
  """
  static {
    aliasFor(native "glMatrix.vec3")
    function create(): vec3 {
      """
      Creates a new, empty vec3
      """
      aliasFor(__js_create)
    }
    function clone(a: vec3): vec3 {
      """
      Creates a new vec3 initialized with values from an existing vector
      """
      aliasFor(__js_clone)
    }
    function length(a: vec3): Number {
      """
      Calculates the length of a vec3
      """
      aliasFor(__js_length)
    }
    function fromValues(x: Number, y: Number, z: Number): vec3 {
      """
      Creates a new vec3 initialized with the given values
      """
      aliasFor(__js_fromValues)
    }
    function copy(out: vec3, a: vec3): vec3 {
      """
      Copy the values from one vec3 to another
      """
      aliasFor(__js_copy)
    }
    function set(out: vec3, x: Number, y: Number, z: Number): vec3 {
      """
      Set the components of a vec3 to the given values
      """
      aliasFor(__js_set)
    }
    function add(out: vec3, a: vec3, b: vec3): vec3 {
      """
      Adds two vec3's
      """
      aliasFor(__js_add)
    }
    function subtract(out: vec3, a: vec3, b: vec3): vec3 {
      """
      Subtracts vector b from vector a
      """
      aliasFor(__js_subtract)
    }
    function multiply(out: vec3, a: vec3, b: vec3): vec3 {
      """
      Multiplies two vec3's
      """
      aliasFor(__js_multiply)
    }
    function divide(out: vec3, a: vec3, b: vec3): vec3 {
      """
      Divides two vec3's
      """
      aliasFor(__js_divide)
    }
    function ceil(out: vec3, a: vec3): vec3 {
      """
      Math.ceil the components of a vec3
      """
      aliasFor(__js_ceil)
    }
    function floor(out: vec3, a: vec3): vec3 {
      """
      Math.floor the components of a vec3
      """
      aliasFor(__js_floor)
    }
    function min(out: vec3, a: vec3, b: vec3): vec3 {
      """
      Returns the minimum of two vec3's
      """
      aliasFor(__js_min)
    }
    function max(out: vec3, a: vec3, b: vec3): vec3 {
      """
      Returns the maximum of two vec3's
      """
      aliasFor(__js_max)
    }
    function round(out: vec3, a: vec3): vec3 {
      """
      Math.round the components of a vec3
      """
      aliasFor(__js_round)
    }
    function scale(out: vec3, a: vec3, b: Number): vec3 {
      """
      Scales a vec3 by a scalar number
      """
      aliasFor(__js_scale)
    }
    function scaleAndAdd(out: vec3, a: vec3, b: vec3, scale: Number): vec3 {
      """
      Adds two vec3's after scaling the second operand by a scalar value
      """
      aliasFor(__js_scaleAndAdd)
    }
    function distance(a: vec3, b: vec3): Number {
      """
      Calculates the euclidian distance between two vec3's
      """
      aliasFor(__js_distance)
    }
    function squaredDistance(a: vec3, b: vec3): Number {
      """
      Calculates the squared euclidian distance between two vec3's
      """
      aliasFor(__js_squaredDistance)
    }
    function squaredLength(a: vec3): Number {
      """
      Calculates the squared length of a vec3
      """
      aliasFor(__js_squaredLength)
    }
    function negate(out: vec3, a: vec3): vec3 {
      """
      Negates the components of a vec3
      """
      aliasFor(__js_negate)
    }
    function inverse(out: vec3, a: vec3): vec3 {
      """
      Returns the inverse of the components of a vec3
      """
      aliasFor(__js_inverse)
    }
    function normalize(out: vec3, a: vec3): vec3 {
      """
      Normalize a vec3
      """
      aliasFor(__js_normalize)
    }
    function dot(a: vec3, b: vec3): Number {
      """
      Calculates the dot product of two vec3's
      """
      aliasFor(__js_dot)
    }
    function cross(out: vec3, a: vec3, b: vec3): vec3 {
      """
      Computes the cross product of two vec3's
      """
      aliasFor(__js_cross)
    }
    function lerp(out: vec3, a: vec3, b: vec3, t: Number): vec3 {
      """
      Performs a linear interpolation between two vec3's
      """
      aliasFor(__js_lerp)
    }
    function slerp(out: vec3, a: vec3, b: vec3, t: Number): vec3 {
      """
      Performs a spherical linear interpolation between two vec3's
      """
      aliasFor(__js_slerp)
    }
    function hermite(out: vec3, a: vec3, b: vec3, c: vec3, d: vec3, t: Number): vec3 {
      """
      Performs a hermite interpolation with two control points
      """
      aliasFor(__js_hermite)
    }
    function bezier(out: vec3, a: vec3, b: vec3, c: vec3, d: vec3, t: Number): vec3 {
      """
      Performs a bezier interpolation with two control points
      """
      aliasFor(__js_bezier)
    }
    function random(out: vec3, scale: Number): vec3 {
      """
      Generates a random vector with the given scale
      """
      aliasFor(__js_random)
    }
    function transformMat4(out: vec3, a: vec3, m: mat4): vec3 {
      """
      Transforms the vec3 with a mat4.
4th vector component is implicitly '1'
      """
      aliasFor(__js_transformMat4)
    }
    function transformMat3(out: vec3, a: vec3, m: mat3): vec3 {
      """
      Transforms the vec3 with a mat3.
      """
      aliasFor(__js_transformMat3)
    }
    function transformQuat(out: vec3, a: vec3, q: quat): vec3 {
      """
      Transforms the vec3 with a quat
Can also be used for dual quaternions. (Multiply it with the real part)
      """
      aliasFor(__js_transformQuat)
    }
    function rotateX(out: vec3, a: vec3, b: vec3, rad: Number): vec3 {
      """
      Rotate a 3D vector around the x-axis
      """
      aliasFor(__js_rotateX)
    }
    function rotateY(out: vec3, a: vec3, b: vec3, rad: Number): vec3 {
      """
      Rotate a 3D vector around the y-axis
      """
      aliasFor(__js_rotateY)
    }
    function rotateZ(out: vec3, a: vec3, b: vec3, rad: Number): vec3 {
      """
      Rotate a 3D vector around the z-axis
      """
      aliasFor(__js_rotateZ)
    }
    function angle(a: vec3, b: vec3): Number {
      """
      Get the angle between two 3D vectors
      """
      aliasFor(__js_angle)
    }
    function zero(out: vec3): vec3 {
      """
      Set the components of a vec3 to zero
      """
      aliasFor(__js_zero)
    }
    function str(a: vec3): String {
      """
      Returns a string representation of a vector
      """
      aliasFor(__js_str)
    }
    function exactEquals(a: vec3, b: vec3): Bool {
      """
      Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
      """
      aliasFor(__js_exactEquals)
    }
    function equals(a: vec3, b: vec3): Bool {
      """
      Returns whether or not the vectors have approximately the same elements in the same position.
      """
      aliasFor(__js_equals)
    }
    function sub(out: vec3, a: vec3, b: vec3): vec3 {
      """
      Alias for {@link vec3.subtract}
      """
      aliasFor(__js_sub)
    }
    function mul(out: vec3, a: vec3, b: vec3): vec3 {
      """
      Alias for {@link vec3.multiply}
      """
      aliasFor(__js_mul)
    }
    function div(out: vec3, a: vec3, b: vec3): vec3 {
      """
      Alias for {@link vec3.divide}
      """
      aliasFor(__js_div)
    }
    function dist(a: vec3, b: vec3): Number {
      """
      Alias for {@link vec3.distance}
      """
      aliasFor(__js_dist)
    }
    function sqrDist(a: vec3, b: vec3): Number {
      """
      Alias for {@link vec3.squaredDistance}
      """
      aliasFor(__js_sqrDist)
    }
    function len(a: vec3): Number {
      """
      Alias for {@link vec3.length}
      """
      aliasFor(__js_len)
    }
    function sqrLen(a: vec3): Number {
      """
      Alias for {@link vec3.squaredLength}
      """
      aliasFor(__js_sqrLen)
    }
  }
  function asFloat32Array(): Float32Array {
    aliasFor(__op_noop__)
  }
}
export interface vec4 {
  """
  https://glmatrix.net/docs/module-vec4.html
  """
  static {
    aliasFor(native "glMatrix.vec4")
    function create(): vec4 {
      """
      Creates a new, empty vec4
      """
      aliasFor(__js_create)
    }
    function clone(a: vec4): vec4 {
      """
      Creates a new vec4 initialized with values from an existing vector
      """
      aliasFor(__js_clone)
    }
    function fromValues(x: Number, y: Number, z: Number, w: Number): vec4 {
      """
      Creates a new vec4 initialized with the given values
      """
      aliasFor(__js_fromValues)
    }
    function copy(out: vec4, a: vec4): vec4 {
      """
      Copy the values from one vec4 to another
      """
      aliasFor(__js_copy)
    }
    function set(out: vec4, x: Number, y: Number, z: Number, w: Number): vec4 {
      """
      Set the components of a vec4 to the given values
      """
      aliasFor(__js_set)
    }
    function add(out: vec4, a: vec4, b: vec4): vec4 {
      """
      Adds two vec4's
      """
      aliasFor(__js_add)
    }
    function subtract(out: vec4, a: vec4, b: vec4): vec4 {
      """
      Subtracts vector b from vector a
      """
      aliasFor(__js_subtract)
    }
    function multiply(out: vec4, a: vec4, b: vec4): vec4 {
      """
      Multiplies two vec4's
      """
      aliasFor(__js_multiply)
    }
    function divide(out: vec4, a: vec4, b: vec4): vec4 {
      """
      Divides two vec4's
      """
      aliasFor(__js_divide)
    }
    function ceil(out: vec4, a: vec4): vec4 {
      """
      Math.ceil the components of a vec4
      """
      aliasFor(__js_ceil)
    }
    function floor(out: vec4, a: vec4): vec4 {
      """
      Math.floor the components of a vec4
      """
      aliasFor(__js_floor)
    }
    function min(out: vec4, a: vec4, b: vec4): vec4 {
      """
      Returns the minimum of two vec4's
      """
      aliasFor(__js_min)
    }
    function max(out: vec4, a: vec4, b: vec4): vec4 {
      """
      Returns the maximum of two vec4's
      """
      aliasFor(__js_max)
    }
    function round(out: vec4, a: vec4): vec4 {
      """
      Math.round the components of a vec4
      """
      aliasFor(__js_round)
    }
    function scale(out: vec4, a: vec4, b: Number): vec4 {
      """
      Scales a vec4 by a scalar number
      """
      aliasFor(__js_scale)
    }
    function scaleAndAdd(out: vec4, a: vec4, b: vec4, scale: Number): vec4 {
      """
      Adds two vec4's after scaling the second operand by a scalar value
      """
      aliasFor(__js_scaleAndAdd)
    }
    function distance(a: vec4, b: vec4): Number {
      """
      Calculates the euclidian distance between two vec4's
      """
      aliasFor(__js_distance)
    }
    function squaredDistance(a: vec4, b: vec4): Number {
      """
      Calculates the squared euclidian distance between two vec4's
      """
      aliasFor(__js_squaredDistance)
    }
    function length(a: vec4): Number {
      """
      Calculates the length of a vec4
      """
      aliasFor(__js_length)
    }
    function squaredLength(a: vec4): Number {
      """
      Calculates the squared length of a vec4
      """
      aliasFor(__js_squaredLength)
    }
    function negate(out: vec4, a: vec4): vec4 {
      """
      Negates the components of a vec4
      """
      aliasFor(__js_negate)
    }
    function inverse(out: vec4, a: vec4): vec4 {
      """
      Returns the inverse of the components of a vec4
      """
      aliasFor(__js_inverse)
    }
    function normalize(out: vec4, a: vec4): vec4 {
      """
      Normalize a vec4
      """
      aliasFor(__js_normalize)
    }
    function dot(a: vec4, b: vec4): Number {
      """
      Calculates the dot product of two vec4's
      """
      aliasFor(__js_dot)
    }
    function cross(result: vec4, U: vec4, V: vec4, W: vec4): vec4 {
      """
      Returns the cross-product of three vectors in a 4-dimensional space
      """
      aliasFor(__js_cross)
    }
    function lerp(out: vec4, a: vec4, b: vec4, t: Number): vec4 {
      """
      Performs a linear interpolation between two vec4's
      """
      aliasFor(__js_lerp)
    }
    function random(out: vec4, scale: Number): vec4 {
      """
      Generates a random vector with the given scale
      """
      aliasFor(__js_random)
    }
    function transformMat4(out: vec4, a: vec4, m: mat4): vec4 {
      """
      Transforms the vec4 with a mat4.
      """
      aliasFor(__js_transformMat4)
    }
    function transformQuat(out: vec4, a: vec4, q: quat): vec4 {
      """
      Transforms the vec4 with a quat
      """
      aliasFor(__js_transformQuat)
    }
    function zero(out: vec4): vec4 {
      """
      Set the components of a vec4 to zero
      """
      aliasFor(__js_zero)
    }
    function str(a: vec4): String {
      """
      Returns a string representation of a vector
      """
      aliasFor(__js_str)
    }
    function exactEquals(a: vec4, b: vec4): Bool {
      """
      Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
      """
      aliasFor(__js_exactEquals)
    }
    function equals(a: vec4, b: vec4): Bool {
      """
      Returns whether or not the vectors have approximately the same elements in the same position.
      """
      aliasFor(__js_equals)
    }
    function sub(out: vec4, a: vec4, b: vec4): vec4 {
      """
      Alias for {@link vec4.subtract}
      """
      aliasFor(__js_sub)
    }
    function mul(out: vec4, a: vec4, b: vec4): vec4 {
      """
      Alias for {@link vec4.multiply}
      """
      aliasFor(__js_mul)
    }
    function div(out: vec4, a: vec4, b: vec4): vec4 {
      """
      Alias for {@link vec4.divide}
      """
      aliasFor(__js_div)
    }
    function dist(a: vec4, b: vec4): Number {
      """
      Alias for {@link vec4.distance}
      """
      aliasFor(__js_dist)
    }
    function sqrDist(a: vec4, b: vec4): Number {
      """
      Alias for {@link vec4.squaredDistance}
      """
      aliasFor(__js_sqrDist)
    }
    function len(a: vec4): Number {
      """
      Alias for {@link vec4.length}
      """
      aliasFor(__js_len)
    }
    function sqrLen(a: vec4): Number {
      """
      Alias for {@link vec4.squaredLength}
      """
      aliasFor(__js_sqrLen)
    }
  }
  function asFloat32Array(): Float32Array {
    aliasFor(__op_noop__)
  }
}
